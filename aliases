# vim: set filetype=sh:#

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias cdd='cd $(python -c "import django, os.path; print os.path.dirname(django.__file__)")'
alias cdr='cd $(git rev-parse --show-toplevel)'
alias ohwait="git st -s --porcelain -uall | awk '{print \$2}' | grep '[.]py\$' | xargs pyflakes"
alias hruns="HTTPS=on ./manage.py runserver 0.0.0.0:8001"
alias msh="./manage.py mshell"
alias dsh="./manage.py dbshell"
alias f="find . -name"
alias F="find . -iname"
alias vd='vim $(git diff --name-only | sort -u)'
alias tls='tmux list-sessions'
alias ta='tmux attach'
alias ta0='tmux attach -t0'
alias ta1='tmux attach -t1'
alias ta2='tmux attach -t2'
alias gs="git st"
alias gci="git ci"
alias gf="git fetch"
alias gm="git merge"
alias gmom="git merge origin/master"
alias ga="git add"
alias gp="git push"
alias gpl="git pull"
alias gd="git diff"
alias gu="git up"
alias pi="pip install"
alias bu="brew update && brew upgrade"
alias -g EL="2>&1 | less"
alias week="date +%W"
alias reset="echo -e c"
alias rssh="ssh -fN -R 8022:localhost:22"
alias ral="source ~/etc/aliases"
[[ $(uname) = 'Darwin' ]] \
    && alias pipu="pip install --upgrade -r requirements-macosx.txt" \
    || alias pipu="pip install --upgrade -r requirements.txt" \
alias -g dime="growlnotife -m Done -s"
alias pytags='ctags --exclude=.env --exclude=migrations --languages=python --python-kinds=-i -R .'
alias rt='./manage.py test -v2'
alias rtc='./manage.py test -v2 --create-db'
alias rtf='./manage.py test -v2 --failed'

vack () { vim -q<( ack -H --nocolor --nogroup --column  "$@" ); }
mkmig () { ./manage.py schemamigration --auto $1 $2 }
mkdmig () { ./manage.py datamigration $1 $2 }
mig ()  { ./manage.py migrate $1 $2 --ignore-ghost-migrations }

runs() {
    ./manage.py runserver 0.0.0.0:${1:-8000}
}

serve() {
    python -m SimpleHTTPServer ${1:-9000}
}

# apt-get install realpath # On Ubuntu
# brew install coreutils # On Mac
with_parents () {
    /usr/bin/which realpath > /dev/null && current=$(realpath ${1:-$PWD})
    /usr/bin/which grealpath > /dev/null && current=$(grealpath ${1:-$PWD})
    [[ -z $current ]] && echo Not found neither realpath, nor grealpath && return 1
    echo -n $current
    while [[ $current != '/' ]]
    do
        current=$(dirname $current)
        echo -n ' ' $current
    done
}

cd () {
    builtin cd "$@"
    if [ -z $VIRTUAL_ENV ]
    then
        # Discover virtualenv
        for d in $(with_parents)
        do
            [ -f $d/.env/bin/activate ] && source $d/.env/bin/activate return 0
        done
    else
        # Deactivate virtualenv if we are not in virtualenv already
        for d in $(with_parents)
        do
            [ -f $d/.env/bin/activate ] && return 0
        done
        deactivate 2> /dev/null
    fi
}

function cdpy() {
    if MODULE_PATH=$(python -c "import $1, os.path; print os.path.dirname($1.__file__)" 2> /dev/null)
    then
        cd $MODULE_PATH
    else
        echo Unknown Python module: $1
        return 1
    fi
}

# Minimally awesome todo
# http://blog.jerodsanto.net/2010/12/minimally-awesome-todos/
export TODO=~/Dropbox/todo.txt
function todo(){ if [ $# -eq 0 ]; then cat $TODO; else echo "â€¢ $@" >> $TODO; fi }
function todone() { sed -i -e "/$*/d" $TODO; }


# pipâ€™s requirements.txt update
updreq() {

    (( $# != 2 )) && { echo "Usage: $0 <requirement> <version>" >&2; return 1}
    requirement=$1
    revision=$2
    grep -q "${requirement}" requirements.txt || { echo "Unknown requirement ${requirement}" >&2; return 2 }
    [[ (( $(grep -c "${requirement}" requirements.txt) -gt 1 )) ]] && { echo "Ambigous requirement ${requirement}" >&2; grep --color=auto "${requirement}" requirements.txt; return 3} 


    if grep -q "^-e .*${requirement}" requirements.txt
    then
        if grep -q "@${revision}.*#egg=.*${requirement}.*" requirements.txt
        then
            echo "requirement ${requirement} already has revision ${revision}" >&2
            return 4
        else
            sed -i "/${requirement}/s/@.\+#/@${revision}#/" requirements.txt
            return 0
        fi
    fi

    version=$revision
    if grep -q "[a-z0-9_-]*${requirement}[a-z0-9_-]*==" requirements.txt
    then
        if grep "^[a-z0-9_-]*${requirement}[a-z0-9_-]*==${version}\s*$" requirements.txt
        then
            echo "requirement ${requirement} already has version ${version}"
            return 5
        else
            sed -i "/${requirement}/s/==.\+/==${version}/" requirements.txt
            return 0
        fi
    fi
        
}

